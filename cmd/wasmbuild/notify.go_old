package main

import (
	"fmt"
	"net/http"
	"strings"
)

// Server-Side Events handles Server-Sent Events for live reload
func (s *ServeCmd) notify(w http.ResponseWriter, r *http.Request, broadcaster *reloadBroadcaster) {
	// Set headers for SSE
	w.Header().Set("Content-Type", "text/event-stream")
	w.Header().Set("Cache-Control", "no-cache")
	w.Header().Set("Connection", "keep-alive")

	flusher, ok := w.(http.Flusher)
	if !ok {
		http.Error(w, "Streaming unsupported", http.StatusInternalServerError)
		return
	}

	logger.Infof("SSE client connected: %s", r.RemoteAddr)

	// Create a client channel and register it
	clientChan := make(chan SSEMessage, 10)
	broadcaster.register(clientChan)
	defer broadcaster.unregister(clientChan)

	// Send initial connection message
	fmt.Fprintf(w, "data: connected\n\n")
	flusher.Flush()

	// Keep connection alive and wait for reload signals
	for {
		select {
		case msg := <-clientChan:
			if msg.Type == "reload" {
				fmt.Fprintf(w, "data: reload\n\n")
				flusher.Flush()
				logger.Infof("Sent reload notification to: %s", r.RemoteAddr)
			} else if msg.Type == "error" {
				// For multi-line error messages, prefix each line with "data: "
				lines := strings.Split(msg.Data, "\n")
				fmt.Fprintf(w, "event: compileerror\n")
				for _, line := range lines {
					fmt.Fprintf(w, "data: %s\n", line)
				}
				fmt.Fprintf(w, "\n")
				flusher.Flush()
				logger.Infof("Sent error notification to: %s", r.RemoteAddr)
			}
		case <-r.Context().Done():
			logger.Infof("SSE client disconnected: %s", r.RemoteAddr)
			return
		}
	}
}
